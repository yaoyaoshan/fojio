# 第二章 内存寻址

## 寻址过程概述

logical address ----分段单元 segmentation unit-----> linear address -----分页单元 paging unit-----> physical address

## 分段单元

### 段寄存器 segmentation register

- 段寄存器用来存放段标识符
- 有6个段寄存器
  - cs：代码段寄存器，指向存放程序指令的段；有一个2位的域，指明cpu的当前特权级 current priviledge level，0和3分别代表内核态和用户态
  - ss：栈段寄存器，指向存放当前程序栈的段
  - ds：数据段寄存器，指向存放静态数据或外部数据的段
  - 其他三个寄存器可存放任意段

### 段描述符 segment descriptor

- 8个字节，描述了段的特征
- 段描述符被放在全局描述符表 Global Descriptor Table 或 局部描述符表 Local Descriptor Table 中
  - GDT：系统只定义一个GDT，GDT在主存中的地址被放在cpu的gdtr寄存器中
  - LDT：每个进程有自己的LDT，当前正被使用的LDT被放在cpu的ldtr寄存器中
- 段描述符（我只记了重要的）=该段第一个字节的线性地址（32位）+该段的长度+该段的特权级 Descriptor Privilege Level：能访问这个段的最小cpu优先级+...

### 段标识符

- 段标识符（我只记了重要的）=GDT或LDT的索引（13位）+指示符（指明该段的描述符是在GDT还是LDT）+...
- 如何计算？如果GDT的起始位置是0x00020000（这个值保存在gdtr中），某段的段标识符的索引号是2，则该段的段描述符的地址是0x00020000+2*8=0x00020010

### 逻辑地址转化为线性地址的过程

逻辑地址=段标识符 segment selector（16位）+段内偏移量（32位）

1. 根据段标识符的指示符，从ldtr或gdtr寄存器中得到LDT或GDT的起始地址
2. 段标识符索引域*8+LDT或GDT的起始地址=段描述符地址
3. （段描述符中记录的）该段第一个字节的线性地址+段内偏移量=线性地址

注意：cpu中有一种非编程寄存器（即程序员不能控制的寄存器），每个非编程寄存器存储了一个段描述符。每当一个段选择符被装入段寄存器r，相应的段描述符就由内存装入到r对应的非编程寄存器中。所以只有当段寄存器内容发生变化时，才会进行1、2这两步，否则直接从非编程寄存器中拿到段描述符即可

## 分页单元

### 页与页框 page frame

- 线性地址被分为多个页，每个页的长度固定。一个页内连续的线性地址被映射到连续的物理地址中
- 主存被分为多个页框，页框的长度固定，和页相同
- 页框和页的区别：页框是主存的一部分，是存储区域；页是一个数据块，可以存放在页框或者磁盘中

### 页目录与页表 page table

- 存放在主存中
- 每个进程有自己的页目录（*1）和页表（\*n）

### 线性地址转化为物理地址的过程

线性地址=目录域 directory（10位）+页表域 table（10位）+偏移量 offset（12位）

假设一个线性地址为0x20021406，则目录域为0x80、页表域为0x21、偏移量为0x406

1. 从cpu的cr3寄存器中获得当前使用的页目录的起始物理地址
2. 目录域是0x80，所以找到页目录的第0x80项，记录着该页对应的页表的起始地址
3. 页表域是0x21，所以找到页表的第0x21项，记录着该页所在页框的起始物理地址
4. 该页所在页框的起始物理地址+偏移量=物理地址

注意：页目录和页表的表项结构是一样的，都（我只记了重要的）=present标志+访问该页表/页所需的cpu最小特权级别...；若present标志=1，则所指的页表/页就在主存中，若present标志为0，则把这个线性地址放到cr2寄存器中，并产生缺页异常

### 保留的页框

内核的代码和数据结构存放在一组保留的页框中，它们所含的页永远不会被交换到磁盘中去

一般而言，这组页框从主存的物理地址0x001000000（即第二个MB）开始，长度由内核的配置决定

### 进程页表

一个进程的地址空间被分为两部分，其中1G为内核空间，只有内核态的进程才能寻址；剩下3G为用户空间，用户态/内核态的进程都可寻址



